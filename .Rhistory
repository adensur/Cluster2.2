l=l/2
}
print(i)
}
init=function(N,sd=1){#generates N particles with x,y,z random coordinates
x=rnorm(N,sd=sd)
y=rnorm(N,sd=sd)
z=rnorm(N,sd=sd)
data.frame(x=x,y=y,z=z)
}
U=function(r){#scalar function. Returns potential energy of r-type object
N=dim(r)[1]
sum=0
for(i in 1:N){
sum1=0
if(i!=N){
for(j in (i+1):N){
sum1=sum1+sum((r[i,]-r[j,])^2)^(-6)
}
}
sum=sum1+sum(r[i,]^2)
}
sum
}
gU=function(r){#returns gradient of r object in same, N*3, form
N=dim(r)[1]
frame=data.frame(x=0,y=0,z=0)
for(i in 1:N){
for(j in 1:3){
sum=0
for(k in 1:N){
if(k!=i){
sum=sum+(r[i,j]-r[k,j])/(sum((r[i,]-r[k,])^2)^4)
}
}
frame[i,j]=2*r[i,j]-6*sum
}
}
frame
}
#gradient descent cycle
l=1         #lambda
K=1000     #number of grad descent steps
N=27       #number of particles
r=init(N)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
else{
l=l/2
}
print(k)
}
l=1         #lambda
K=1000     #number of grad descent steps
N=27       #number of particles
r=init(N)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
else{
l=l/2
}
print(c(k),U(r))
}
l=1         #lambda
K=1000     #number of grad descent steps
N=27       #number of particles
r=init(N)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
else{
l=l/2
}
print(c(k,U(r),l)
}
#gradient descent cycle
l=1         #lambda
K=1000     #number of grad descent steps
N=27       #number of particles
r=init(N)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
else{
l=l/2
}
print(c(k,U(r),l))
}
r
library(rgl)
x=r$x
y=r$y
z=r$z
plot3d(x,y,z)
init=function(N,sd=1){#generates N particles with x,y,z random coordinates
x=rnorm(N,sd=sd)
y=rnorm(N,sd=sd)
data.frame(x=x,y=y)
}
r=init(17)
r
U=function(r){#scalar function. Returns potential energy of r-type object
N=dim(r)[1]
sum=0
for(i in 1:N){
sum1=0
if(i!=N){
for(j in (i+1):N){
sum1=sum1+sum((r[i,]-r[j,])^2)^(-6)
}
}
sum=sum1+sum(r[i,]^2)
}
sum
}
U(r)
gU=function(r){#returns gradient of r object in same, N*3, form
N=dim(r)[1]
frame=data.frame(x=0,y=0,z=0)
for(i in 1:N){
for(j in 1:2){
sum=0
for(k in 1:N){
if(k!=i){
sum=sum+(r[i,j]-r[k,j])/(sum((r[i,]-r[k,])^2)^4)
}
}
frame[i,j]=2*r[i,j]-6*sum
}
}
frame
}
gU(r)
gU=function(r){#returns gradient of r object in same, N*3, form
N=dim(r)[1]
frame=data.frame(x=0,y=0)
for(i in 1:N){
for(j in 1:2){
sum=0
for(k in 1:N){
if(k!=i){
sum=sum+(r[i,j]-r[k,j])/(sum((r[i,]-r[k,])^2)^4)
}
}
frame[i,j]=2*r[i,j]-6*sum
}
}
frame
}
gU(r)
r
i=3
r[-3.]
r[-3,]
init=function(N,sd=1){#generates N particles with x,y,z random coordinates
x=rnorm(N,sd=sd)
y=rnorm(N,sd=sd)
data.frame(x=x,y=y)
}
U=function(r){#scalar function. Returns potential energy of r-type object
N=dim(r)[1]
sum=0
for(i in 1:N){
sum1=0
if(i!=N){
for(j in (i+1):N){
sum1=sum1+sum((r[i,]-r[j,])^2)^(-6)
}
}
sum=sum1+sum(r[i,]^2)
}
sum
}
gU=function(r){#returns gradient of r object in same, N*3, form
N=dim(r)[1]
frame=data.frame(x=0,y=0)
for(i in 1:N){
for(j in 1:2){
sum=0
for(k in 1:N){
if(k!=i){
sum=sum+(r[i,j]-r[k,j])/(sum((r[i,]-r[k,])^2)^4)
}
}
frame[i,j]=2*r[i,j]-6*sum
}
}
frame
}
l=1         #lambda
K=1000     #number of grad descent steps
N=17       #number of particles
r=init(N)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
else{
l=l/2
}
print(c(k,U(r),l))
}
r
plot(x,y)
i=3
k=7
j=1
r[i,]
N=dim(r)[1]
N
frame=data.frame(x=0,y=0)
frame
sum=0
sum=sum+(r[i,j]-r[k,j])/(sum((r[i,]-r[k,])^2)^4)
sum
search()
sum
sum(1:3)
init(27)
r=init(27)
r
U(r)
r=init(1)
r
U(r)
r^2
sum(r^2)
gU(r)
2sum(r)
2*sum(r)
2*r
gU(r)
#gradient descent cycle
l=1         #lambda
K=1000     #number of grad descent steps
N=17       #number of particles
r=init(N)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
else{
l=l/2
}
print(c(k,U(r),l))
}
gU(r)
l
r
r=init(1)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
else{
l=l/2
}
print(c(k,U(r),l))
}
r
plot(r)
plot(r)
points(c(0,0),col="red")
plot(c(r,c(0,0)))
c(r,c(0,0))
plot(c(r,0,0))
c(r,o,0)
c(r,0,0)
r
class(r)
U(r)
r
U(r)
gU(r)
U(r)
U(r-gU(r))
r
gU(r)
r-gU(r)
U(r)
U(r-0.1*gU(r))
l
l=1
U(r-l*gU(r))
U(r)
l=0.5
U(r-l*gU(r))
l=1
gu=gU(r)
gu
l
r
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
else{
l=l/2
}
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
else{
l=l/2
}
if(FALSE){
}
else{
print("ququ")
}
?if
?if()
?sum()
?if()
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
r
lk
l
l=1
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}
else{
l=l/2
l
l=1
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}else{
l=l/2
}
l
l=1
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}else{
l=l/2
}
print(c(k,U(r),l))
}
l=1         #lambda
K=1000     #number of grad descent steps
N=17       #number of particles
r=init(N)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}else{
l=l/2
}
print(c(k,U(r),l))
}
plot(r)
r
gU(r)
l
r-gU(r)
r-0.1*gU(r)
U(r)
U(r=0.1*gU(r))
l=1         #lambda
K=1000     #number of grad descent steps
N=17       #number of particles
r=init(N)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}else{
l=l*0.9
}
print(c(k,U(r),l))
}
r
U(r)
U(r-gU(r))
gU(r)
r
#gradient descent cycle
l=1         #lambda
K=1000     #number of grad descent steps
N=17       #number of particles
r=init(N)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}else{
l=l*0.9
}
print(c(k,U(r),l))
}
r
plot(r)
r=init(2)
r
U(r)
sum(r^2)
r
U(r)
r
r[1,1]^2+r[1,2]^2+r[2,1]^2+r[2,2]^2
N=dim(r)[1]
N
sum=0
sum(r[i,]^2)
i=1
sum(r[i,]^2)
i
N
j=2
sum1=sum1+sum((r[i,]-r[j,])^2)^(-6)
sum1=0
sum1=sum1+sum((r[i,]-r[j,])^2)^(-6)
sum1
sum=sum1+sum(r[i,]^2)
sum
N=dim(r)[1]
sum=0
for(i in 1:N){
sum1=0
if(i!=N){
for(j in (i+1):N){
sum1=sum1+sum((r[i,]-r[j,])^2)^(-6)
}
}
sum=sum1+sum(r[i,]^2)
}
sum
N=dim(r)[1]
sum=0
for(i in 1:N){
sum1=0
if(i!=N){
for(j in (i+1):N){
sum1=sum1+sum((r[i,]-r[j,])^2)^(-6)
print(sum1)
}
}
sum=sum1+sum(r[i,]^2)
print(sum)
}
sum
U=function(r){#scalar function. Returns potential energy of r-type object
N=dim(r)[1]
sum=0
for(i in 1:N){
sum1=0
if(i!=N){
for(j in (i+1):N){
sum1=sum1+sum((r[i,]-r[j,])^2)^(-6)
print(sum1)
}
}
sum=sum+sum1+sum(r[i,]^2)
print(sum)
}
sum
}
U(r)
U=function(r){#scalar function. Returns potential energy of r-type object
N=dim(r)[1]
sum=0
for(i in 1:N){
sum1=0
if(i!=N){
for(j in (i+1):N){
sum1=sum1+sum((r[i,]-r[j,])^2)^(-6)
}
}
sum=sum+sum1+sum(r[i,]^2)
}
sum
}
U(r)
l=1         #lambda
K=1000     #number of grad descent steps
N=17       #number of particles
r=init(N)
for(k in 1:K){
gu=gU(r)
if(U(r-l*gu)<U(r)){
r=r-l*gu
}else{
l=l/2
}
print(c(k,U(r),l))
}
plot(r)
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
dir()
